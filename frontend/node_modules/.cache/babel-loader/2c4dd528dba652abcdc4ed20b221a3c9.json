{"ast":null,"code":"let secrets = {};\n\ntry {\n  secrets = require(\"./secrets\").secrets; // create your secrets.js file using the template\n} catch {\n  console.log(\"You need to setup frontend/src/utils/secrets.js using the secrets.template.js file\");\n  alert(\"You need to setup frontend/src/utils/secrets.js using the secrets.template.js file\");\n}\n\nconst algosdk = require(\"algosdk\"); // This will handle all algosdk, indexer, and AlgoSigner code\n\n\nclass AlgoHandler {\n  constructor() {\n    // Waits a little while then checks to see if the AlgoSigner extension is installed\n    setTimeout(200, () => {\n      if (typeof window.AlgoSigner == \"undefined\") {\n        console.log(\"Please install the AlgoSigner extension\");\n        alert(\"Please install the AlgoSigner extension\");\n        return;\n      }\n    }); // Setup the algod client using the secrets imported variable\n    // TODO -----------------------------------------------------------------------------\n\n    this.algodClient = null; // Setup the indexer client using the secrets imported variable\n    // TODO -----------------------------------------------------------------------------\n\n    this.indexerClient = null;\n  }\n  /**\n   * Attempts to connect to the accounts present in the browser's AlgoSigner addon.\n   *\n   * @returns {string[]} - array of all account addresses in string format.\n   */\n\n\n  async getAlgoSignerAccounts() {\n    // This variable will be returned after populated\n    let accounts = []; // Attempt to connect to AlgoSigner, note you will have to use the \"await\" keyword\n    // If this fails or an error occurs, return an empty array\n    // TODO -----------------------------------------------------------------------------\n    // Retrieve all the AlgoSigner accounts on the TestNet\n    // Note they may be in this format: [{address: \"address1\"}, {address: \"address2\"}, etc]\n    // TODO -----------------------------------------------------------------------------\n    // Return the addresses in array format: [\"address1\", \"address2\", \"address3\", etc]\n\n    return accounts;\n  }\n  /**\n   * Decodes base64 string to JavaScript standard string.\n   * \n   * @param {string} encodedString - string encoded in base64\n   * @returns {string} - regular JavaScript string \n   */\n\n\n  base64ToString(encodedString) {\n    return Buffer.from(encodedString, \"base64\").toString();\n  }\n  /**\n   * Retrieves and returns the last Algorand TestNet round\n   * @returns {Number} - the last Algorand TestNet round\n   */\n\n\n  async getLatestRound() {\n    // Retrieve the algod client status\n    // Return the \"last-round\" value from that status\n    // TODO -----------------------------------------------------------------------------\n    return 0;\n  }\n  /** \n   * Retrieves and returns the current global variable values in the given app (appID).\n   *\n   * @param {number} appID - App ID (aka index) of the Algorand smart contract app.\n   * @returns {object} - Javascript object of election variables mapped to their respective values.\n   * \n   * @example \n   * // returns \n   * //   {\n   * //     \"Creator\": \"fjlasjfskfa...\",\n   * //     \"VoteOptions\": \"A,B,C,D\",\n   * //     \"VotesFor0\": 0,\n   * //     \"VotesFor1\": 0,\n   * //     ...\n   * //   } \n   * getElectionState(appID)\n   */\n\n\n  async getElectionState(appID) {\n    // newState will be returned once it's filled with data\n    let newState = {}; // Use the algodClient to get the the app details\n    // TODO -----------------------------------------------------------------------------\n\n    let app = {}; // The data might have a complex structure, feel free to console.log it to see the structure\n    // Go through the data and add the global state variables and values to our newState object (dictionary)\n\n    console.log(\"Application's global state:\");\n\n    for (let x of app[\"params\"][\"global-state\"]) {\n      console.log(x); // Decode the object key\n\n      let key = this.base64ToString(x[\"key\"]); // Bytes values need to be decoded\n      // Addresses stored as bytes need a special decoding process which we have done for you :)\n\n      let bytesVal = this.base64ToString(x[\"value\"][\"bytes\"]); // uint types don't need to be decoded\n\n      let uintVal = x[\"value\"][\"uint\"]; // Type is 1 if the variable is the bytes value, 2 if the variable is actually the uint value\n\n      let valType = x[\"value\"][\"type\"]; // set the value for the key in our newState object to the correct value\n\n      newState[key] = valType == 1 ? bytesVal : uintVal;\n    } // Add the creator's address\n\n\n    newState[\"Creator\"] = app[\"params\"][\"creator\"]; // return the newState\n\n    return newState;\n  }\n  /** \n   * Finds all accounts that have opted-in to the specified app and returns their local states.\n   *\n   * @param {number} appID - App ID (aka index) of the Algorand smart contract app.\n   * @returns {object} - Object of addresses mapped to an object of the addresses' key-value \n   * local state.\n   * \n   * @example \n   * // returns \n   * //   {\n   * //     \"jsdalkfjsd...\": {\n   * //       \"can_vote\": \"yes\", \n   * //       \"voted\": 2\n   * //     }, \n   * //     \"fdsfdsaf...\": {\n   * //       \"can_vote\": \"no\"\n   * //     }\n   * //   }\n   * getAllLocalStates(appID)\n   */\n\n\n  async getAllLocalStates(appID) {\n    // allLocalStates will be returned once it's filled with data\n    let allLocalStates = {}; // Use this.indexerClient to find all the accounts who have appID associated with their account\n    // TODO -----------------------------------------------------------------------------\n    // The resultant JavaScript object (dictionary) may have a complex structure\n    // Try to console.log it out to see the structure\n    // Go through the data and fill allLocalStates to contain all the users' local states\n    // Note that the *keys* of smart contract local state variables will need to be decoded using \n    // our this.base64ToString(value) function\n    // The actual values will also need to be decoded if they are bytes\n    // If they are uints they do not need decoding\n    // TODO -----------------------------------------------------------------------------\n    // Return your JavaScript object\n\n    return allLocalStates;\n  }\n  /** \n   * Signs the given transaction using AlgoSigner then sends it out to be added to the blockchain.\n   *\n   * @param {AlgoSDK Transaction} txn - Transaction that needs to be signed and sent.\n   */\n\n\n  async signAndSend(txn) {// Transactions will need to be encoded to Base64. AlgoSigner has a builtin method for this\n    // TODO -----------------------------------------------------------------------------\n    // Sign the transaction with AlgoSigner\n    // TODO -----------------------------------------------------------------------------\n    // Send the message with AlgoSigner\n    // TODO -----------------------------------------------------------------------------\n  }\n  /** \n   * Sends a transaction that opts in the given account to the given app.\n   *\n   * @param {string} address - Address of the user who wants to opt into the election.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n\n\n  async optInAccount(address, appID) {// Get the suggested params for the transaction\n    // TODO -----------------------------------------------------------------------------\n    // Create the transaction to opt in\n    // TODO -----------------------------------------------------------------------------\n    // Sign and send the transaction with our this.signAndSend function\n    // TODO -----------------------------------------------------------------------------\n  }\n  /** \n   * Sends a transaction from the creator to the given app to approve/reject the given user.\n   *\n   * @param {string} creatorAddress - Address of the creator, who is allowed to approve/reject.\n   * @param {string} userAddress - Address of the user who is being approved/rejected.\n   * @param {string} yesOrNo - \"yes\" or \"no\" corresponding to whether user should be allowed to vote \n   * or not.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n\n\n  async updateUserStatus(creatorAddress, userAddress, yesOrNo, appID) {// Get the suggested params for the transaction\n    // TODO -----------------------------------------------------------------------------\n    // Setup the application argument array, note that application arguments need to be encoded\n    // Strings need to be encoded into Uint8Array\n    // Addresses, *only* when passed as *arguments*, need to be decoded with algosdk inbuilt \n    // decodeAddress function and have their public key value used\n    // The first argument should be the identifier of the smart contract method.\n    // In this case the identifier is \"update_user_status\"\n    // TODO -----------------------------------------------------------------------------\n    // Create the transaction with proper app argument array\n    // For this application transaction make sure to include the optional array of accounts \n    // including both the creator's account and also the user's account \n    // (both in regular string format, algosdk automatically converts these when used this way)\n    // TODO -----------------------------------------------------------------------------\n    // Sign and send the transaction with our this.signAndSend function\n    // TODO -----------------------------------------------------------------------------\n  }\n  /** \n   * Sends a transaction from the given user to vote for the given option in the given election app.\n   *\n   * @param {string} address - Address of the user trying to vote.\n   * @param {number} optionIndex - Index (starting at 0) corresponding to the user's vote, \n   * ie in \"A,B,C\" the optionIndex for C would be index 2.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n\n\n  async vote(address, optionIndex, appID) {// The first argument should be the identifier of the smart contract method.\n    // In this case the identifier is \"vote\"\n    // TODO -----------------------------------------------------------------------------\n  }\n  /** \n   * Sends a transaction from given account to close out of the given app.\n   *\n   * @param {string} address - Address of the user trying to close out.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n\n\n  async closeOut(address, appID) {// TODO -----------------------------------------------------------------------------\n  }\n  /** \n   * Sends a transaction from the given user to the given app to clear state of the app.\n   *\n   * @param {string} address - Address of the user trying to clear state.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n\n\n  async clearState(address, appID) {// TODO -----------------------------------------------------------------------------\n  }\n\n} // create and export a singular AlgoHandler instance\n\n\nconst mainAlgoHandler = new AlgoHandler();\nexport default mainAlgoHandler;","map":{"version":3,"sources":["/Users/jasonschreiber/Documents/UPenn Documents/Junior Year/Spring/CIS 2330/Practical-HW4/frontend/src/utils/AlgoHandler.js"],"names":["secrets","require","console","log","alert","algosdk","AlgoHandler","constructor","setTimeout","window","AlgoSigner","algodClient","indexerClient","getAlgoSignerAccounts","accounts","base64ToString","encodedString","Buffer","from","toString","getLatestRound","getElectionState","appID","newState","app","x","key","bytesVal","uintVal","valType","getAllLocalStates","allLocalStates","signAndSend","txn","optInAccount","address","updateUserStatus","creatorAddress","userAddress","yesOrNo","vote","optionIndex","closeOut","clearState","mainAlgoHandler"],"mappings":"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","sourcesContent":["let secrets = {};\ntry {\n  secrets = require(\"./secrets\").secrets; // create your secrets.js file using the template\n} catch {\n  console.log(\"You need to setup frontend/src/utils/secrets.js using the secrets.template.js file\");\n  alert(\"You need to setup frontend/src/utils/secrets.js using the secrets.template.js file\");\n}\n\nconst algosdk = require(\"algosdk\");\n\n// This will handle all algosdk, indexer, and AlgoSigner code\nclass AlgoHandler {\n  constructor() {\n    // Waits a little while then checks to see if the AlgoSigner extension is installed\n    setTimeout(200, () => {\n      if (typeof window.AlgoSigner == \"undefined\") {\n        console.log(\"Please install the AlgoSigner extension\");\n        alert(\"Please install the AlgoSigner extension\");\n        return;\n      }\n    });\n\n    // Setup the algod client using the secrets imported variable\n    // TODO -----------------------------------------------------------------------------\n    this.algodClient = null;\n\n    // Setup the indexer client using the secrets imported variable\n    // TODO -----------------------------------------------------------------------------\n    this.indexerClient = null;\n  }\n\n  /**\n   * Attempts to connect to the accounts present in the browser's AlgoSigner addon.\n   *\n   * @returns {string[]} - array of all account addresses in string format.\n   */\n  async getAlgoSignerAccounts() {\n    // This variable will be returned after populated\n    let accounts = [];\n\n    // Attempt to connect to AlgoSigner, note you will have to use the \"await\" keyword\n    // If this fails or an error occurs, return an empty array\n    // TODO -----------------------------------------------------------------------------\n\n\n    // Retrieve all the AlgoSigner accounts on the TestNet\n    // Note they may be in this format: [{address: \"address1\"}, {address: \"address2\"}, etc]\n    // TODO -----------------------------------------------------------------------------\n\n\n    // Return the addresses in array format: [\"address1\", \"address2\", \"address3\", etc]\n    return accounts;\n  }\n\n  /**\n   * Decodes base64 string to JavaScript standard string.\n   * \n   * @param {string} encodedString - string encoded in base64\n   * @returns {string} - regular JavaScript string \n   */\n  base64ToString(encodedString) {\n    return Buffer.from(encodedString, \"base64\").toString();\n  }\n\n  /**\n   * Retrieves and returns the last Algorand TestNet round\n   * @returns {Number} - the last Algorand TestNet round\n   */\n  async getLatestRound() {\n    // Retrieve the algod client status\n    // Return the \"last-round\" value from that status\n    // TODO -----------------------------------------------------------------------------\n    return 0;\n  }\n\n  /** \n   * Retrieves and returns the current global variable values in the given app (appID).\n   *\n   * @param {number} appID - App ID (aka index) of the Algorand smart contract app.\n   * @returns {object} - Javascript object of election variables mapped to their respective values.\n   * \n   * @example \n   * // returns \n   * //   {\n   * //     \"Creator\": \"fjlasjfskfa...\",\n   * //     \"VoteOptions\": \"A,B,C,D\",\n   * //     \"VotesFor0\": 0,\n   * //     \"VotesFor1\": 0,\n   * //     ...\n   * //   } \n   * getElectionState(appID)\n   */\n  async getElectionState(appID) {\n    // newState will be returned once it's filled with data\n    let newState = {};\n\n    // Use the algodClient to get the the app details\n    // TODO -----------------------------------------------------------------------------\n    let app = {};\n\n    // The data might have a complex structure, feel free to console.log it to see the structure\n\n    // Go through the data and add the global state variables and values to our newState object (dictionary)\n    console.log(\"Application's global state:\");\n    for (let x of app[\"params\"][\"global-state\"]) {\n      console.log(x);\n\n      // Decode the object key\n      let key = this.base64ToString(x[\"key\"]);\n\n      // Bytes values need to be decoded\n      // Addresses stored as bytes need a special decoding process which we have done for you :)\n      let bytesVal = this.base64ToString(x[\"value\"][\"bytes\"]);\n      \n      // uint types don't need to be decoded\n      let uintVal = x[\"value\"][\"uint\"];\n\n      // Type is 1 if the variable is the bytes value, 2 if the variable is actually the uint value\n      let valType = x[\"value\"][\"type\"];\n\n      // set the value for the key in our newState object to the correct value\n      newState[key] = valType == 1 ? bytesVal : uintVal;\n    }\n\n    // Add the creator's address\n    newState[\"Creator\"] = app[\"params\"][\"creator\"];\n\n    // return the newState\n    return newState;\n  }\n\n  /** \n   * Finds all accounts that have opted-in to the specified app and returns their local states.\n   *\n   * @param {number} appID - App ID (aka index) of the Algorand smart contract app.\n   * @returns {object} - Object of addresses mapped to an object of the addresses' key-value \n   * local state.\n   * \n   * @example \n   * // returns \n   * //   {\n   * //     \"jsdalkfjsd...\": {\n   * //       \"can_vote\": \"yes\", \n   * //       \"voted\": 2\n   * //     }, \n   * //     \"fdsfdsaf...\": {\n   * //       \"can_vote\": \"no\"\n   * //     }\n   * //   }\n   * getAllLocalStates(appID)\n   */\n  async getAllLocalStates(appID) {\n    // allLocalStates will be returned once it's filled with data\n    let allLocalStates = {};\n\n    // Use this.indexerClient to find all the accounts who have appID associated with their account\n    // TODO -----------------------------------------------------------------------------\n\n    // The resultant JavaScript object (dictionary) may have a complex structure\n    // Try to console.log it out to see the structure\n\n    // Go through the data and fill allLocalStates to contain all the users' local states\n    // Note that the *keys* of smart contract local state variables will need to be decoded using \n    // our this.base64ToString(value) function\n    // The actual values will also need to be decoded if they are bytes\n    // If they are uints they do not need decoding\n    // TODO -----------------------------------------------------------------------------\n\n    // Return your JavaScript object\n    return allLocalStates;\n  }\n\n  /** \n   * Signs the given transaction using AlgoSigner then sends it out to be added to the blockchain.\n   *\n   * @param {AlgoSDK Transaction} txn - Transaction that needs to be signed and sent.\n   */\n  async signAndSend(txn) {\n    // Transactions will need to be encoded to Base64. AlgoSigner has a builtin method for this\n    // TODO -----------------------------------------------------------------------------\n\n\n    // Sign the transaction with AlgoSigner\n    // TODO -----------------------------------------------------------------------------\n\n\n    // Send the message with AlgoSigner\n    // TODO -----------------------------------------------------------------------------\n  }\n\n  /** \n   * Sends a transaction that opts in the given account to the given app.\n   *\n   * @param {string} address - Address of the user who wants to opt into the election.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n  async optInAccount(address, appID) {\n    // Get the suggested params for the transaction\n    // TODO -----------------------------------------------------------------------------\n\n    // Create the transaction to opt in\n    // TODO -----------------------------------------------------------------------------\n\n    // Sign and send the transaction with our this.signAndSend function\n    // TODO -----------------------------------------------------------------------------\n\n  }\n\n  /** \n   * Sends a transaction from the creator to the given app to approve/reject the given user.\n   *\n   * @param {string} creatorAddress - Address of the creator, who is allowed to approve/reject.\n   * @param {string} userAddress - Address of the user who is being approved/rejected.\n   * @param {string} yesOrNo - \"yes\" or \"no\" corresponding to whether user should be allowed to vote \n   * or not.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n  async updateUserStatus(creatorAddress, userAddress, yesOrNo, appID) {\n    // Get the suggested params for the transaction\n    // TODO -----------------------------------------------------------------------------\n\n    // Setup the application argument array, note that application arguments need to be encoded\n    // Strings need to be encoded into Uint8Array\n    // Addresses, *only* when passed as *arguments*, need to be decoded with algosdk inbuilt \n    // decodeAddress function and have their public key value used\n    // The first argument should be the identifier of the smart contract method.\n    // In this case the identifier is \"update_user_status\"\n    // TODO -----------------------------------------------------------------------------\n\n    // Create the transaction with proper app argument array\n    // For this application transaction make sure to include the optional array of accounts \n    // including both the creator's account and also the user's account \n    // (both in regular string format, algosdk automatically converts these when used this way)\n    // TODO -----------------------------------------------------------------------------\n\n    // Sign and send the transaction with our this.signAndSend function\n    // TODO -----------------------------------------------------------------------------\n  }\n\n  /** \n   * Sends a transaction from the given user to vote for the given option in the given election app.\n   *\n   * @param {string} address - Address of the user trying to vote.\n   * @param {number} optionIndex - Index (starting at 0) corresponding to the user's vote, \n   * ie in \"A,B,C\" the optionIndex for C would be index 2.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n  async vote(address, optionIndex, appID) {\n    // The first argument should be the identifier of the smart contract method.\n    // In this case the identifier is \"vote\"\n    // TODO -----------------------------------------------------------------------------\n  }\n\n  /** \n   * Sends a transaction from given account to close out of the given app.\n   *\n   * @param {string} address - Address of the user trying to close out.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n  async closeOut(address, appID) {\n    // TODO -----------------------------------------------------------------------------\n  }\n\n  /** \n   * Sends a transaction from the given user to the given app to clear state of the app.\n   *\n   * @param {string} address - Address of the user trying to clear state.\n   * @param {number} appID - App ID (aka index) of the smart contract app.\n   */\n  async clearState(address, appID) {\n    // TODO -----------------------------------------------------------------------------\n  }\n}\n\n// create and export a singular AlgoHandler instance\nconst mainAlgoHandler = new AlgoHandler();\n\nexport default mainAlgoHandler;\n"]},"metadata":{},"sourceType":"module"}